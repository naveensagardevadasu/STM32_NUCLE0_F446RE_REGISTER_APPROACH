/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "pll.h"
#include "sysTick.h"
#include<stdbool.h>
#include <stdio.h>
#include "stm32f446xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




#define PA5_AF_MODE (1 << 11)
#define PA5_AF1     (1 << 20)



volatile uint32_t ms_counter = 0;
volatile uint32_t millis = 0;

//void SysTick_Init(){
//    SysTick->VAL = 0;
//    SysTick->LOAD = (HCLK_FREQ / 1000)- 1;
//    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
//                    SysTick_CTRL_TICKINT_Msk |
//                    SysTick_CTRL_ENABLE_Msk;
//}
//
//void SysTick_Handler(){
//    if (ms_counter) ms_counter--;
//    millis++;
//}

void delay_ms(uint32_t ms){
    ms_counter = ms;
    while (ms_counter);
}

uint32_t getMillis(){
    return millis;
}



//void clockSpeed_PLL(){
//
//    RCC->CR |= RCC_CR_HSION;
//    while (!(RCC->CR & RCC_CR_HSIRDY));
//
//    RCC->PLLCFGR = (PLL_M) | (PLL_N << 6) | (PLL_P << 16) | (PLL_Q << 24);
//    RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLSRC;
//
//    RCC->CFGR |= RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE2_DIV2 | RCC_CFGR_PPRE1_DIV4;
//
//    RCC->CR |= RCC_CR_PLLON;
//    while (!(RCC->CR & RCC_CR_PLLRDY));
//
//    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
//
//    PWR->CR |= PWR_CR_ODEN;
//    while (!(PWR->CSR & PWR_CSR_ODRDY)) ;
//
//    PWR->CR |= PWR_CR_ODSWEN;
//    while (!(PWR->CSR & PWR_CSR_ODSWRDY)) ;
//
//    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_5WS;
//
//    RCC->CFGR &=~ RCC_CFGR_SW;
//    RCC->CFGR |= RCC_CFGR_SW_PLL;
//    while ((RCC->CFGR & RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
//
//}


int main(){

    clockSpeed_PLL();
    SysTick_Init();

    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    GPIOA->AFR[0] |= PA5_AF1;
    GPIOA->MODER |= PA5_AF_MODE;

    TIM2->ARR = 255;

    TIM2->CCMR1 = TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;
    TIM2->CCER |= TIM_CCER_CC1E;
    TIM2->CR1 |= TIM_CR1_CEN;

    short brightness = 0;
    short fadeAmount = 2;

    while(1){
        TIM2->CCR1 = brightness;

        brightness += fadeAmount;

        if (brightness <= 0 || brightness >= 255) {
            fadeAmount = -fadeAmount;
        }

        delay_ms(10);
    };
}
